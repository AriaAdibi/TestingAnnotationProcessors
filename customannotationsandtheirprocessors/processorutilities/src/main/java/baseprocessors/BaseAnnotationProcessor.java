package baseprocessors;

import com.google.common.base.Predicates;
import com.google.common.collect.*;
import lombok.Data;
import utils.MoreElements;
import utils.MoreTypes;

import javax.annotation.processing.*;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Name;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.ErrorType;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic;
import java.util.LinkedHashSet;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.ImmutableSet.toImmutableSet;
import static com.google.common.collect.Iterables.transform;
import static com.google.common.collect.Multimaps.filterKeys;
import static utils.MoreElements.getEnclosingType;

/**
 * An abstract {@link Processor} implementation that defers processing of {@link Element}s
 * to later rounds if they cannot be processed. Packages declared (and annotated) in
 * {@code package-info.java} and type elements are tracked directly, and all other elements
 * are tracked via their nearest enclosing type.
 *
 * <h3>Ill-formed elements are deferred</h3>
 *
 * <p>Any annotated element whose nearest enclosing type is not well-formed is deferred, and
 * not passed to any {@code ProcessingStep}. This helps processors to avoid many common pitfalls,
 * such as {@link ErrorType} instances, {@link ClassCastException}s and badly coerced types.
 *
 * <p>A non-package element is considered well-formed if its type, type parameters, parameters,
 * default values, supertypes, annotations, and enclosed elements are. Package elements are treated
 * similarly, except that their enclosed elements are not validated. See {@link
 * SuperficialValidation#validateElement(Element)} for details.
 *
 * <p>The primary disadvantage to this validation is that any element that forms a circular
 * dependency with a type generated by another {@code BaseAnnotationProcessor} will never compile
 * because the element will never be fully complete. All such compilations will fail with an error
 * message on the offending type that describes the issue.
 *
 * <h3>The usage</h3>
 *
 * <p>Subclasses put their processing logic in {@link ProcessingStep} implementations. The
 * {@code ProcessingStep} is a unit of processing logic that runs under the guarantee that all
 * elements are complete and well-formed. A {@code ProcessingStep} may reject elements that are
 * not ready for processing but might be at a later processing step or round.
 *
 * <p> The processing steps are passed to the processor by returning them in the
 * {@link #processingSteps()} method, and they have access to
 * <ul>
 *    <li>{@code processingEnv}, the {@link ProcessingEnvironment}</li>
 *    <li>{@code eltUtils}, the default element utility class {@link Elements}
 *        (Class {@link MoreElements} provides additional utilities)</li>
 *    <li>{@code typeUtils}, the default type utility class {@link Types}
 *        (Class {@link MoreTypes} provides additional utilities)</li>
 *    <li>{@code messager}, the default annotation processor messager {@link Messager}</li>
 *    <li>{@code filer}, the default annotation processor file creator {@link Filer}</li>
 * </ul>
 *
 * <p>Any logic that needs to happen once per round should be specified in {@link
 * #postRoundProcess(RoundEnvironment)} and {@link #preRoundProcess(RoundEnvironment)} methods.
 *
 * <p>Claiming of the annotation(s) by the processor can be achieved by overriding the
 * {@link #shouldClaimAnnotations()} method.
 *
 * <h3>Each {@code ProcessingStep} can defer elements</h3>
 *
 * <p>Each {@code ProcessingStep} can defer elements by including them in the set returned by {@link
 * ProcessingStep#process(ImmutableSetMultimap)}; elements deferred by a processing step will be
 * passed back to that processing step in a later round of processing.
 *
 * <p>This feature is useful when one processor may depend on code generated by another, independent
 * processor, in a way that isn't caught by the well-formedness check described above. For example,
 * if an element {@code A} cannot be processed because processing it depends on the existence of
 * some class {@code B}, then {@code A} should be deferred until a later round of processing, when
 * {@code B} will have been generated by another processor.
 *
 * <p>If {@code A} directly references {@code B}, then the well-formedness check will correctly
 * defer processing of {@code A} until {@code B} has been generated.
 *
 * <p>However, if {@code A} references {@code B} only indirectly (for example, from within a method
 * body), then the well-formedness check will not defer processing {@code A}, but a processing step
 * can reject {@code A}.
 *
 * <h3>The processor contract</h3>
 *
 * <p>As specified in {@link Processor} documentation, to be robust when running in different tool
 * implementations, an annotation processor should have the following properties:
 * <ol>
 *    <li>The result of processing a given input is not a function of the presence or absence
 *        of other inputs (orthogonality)</li>
 *    <li>Processing the same input produces the same output (consistency)</li>
 *    <li>Processing input A followed by processing input B is equivalent to processing B
 *        then A (commutativity)</li>
 *    <li>Processing an input does not rely on the presence of the output of other annotation
 *        processors (independence)</li>
 * </ol>
 *
 * <p> Although, it might seem that {@code BaseAnnotationProcessor} handles the independence
 * property, this is not the case. As noted above, indirect accesses are not caught by well-formedness
 * validations; and hence, the independence property cannot be fully guaranteed. The user vigilance
 * is still required to make sure that all the aforementioned properties are adhered to. On the
 * positive side, {@code BaseAnnotationProcessor} alleviates the need for most checks and pitfalls
 * associated with independence, and orthogonality properties.
 */
public abstract class BaseAnnotationProcessor extends AbstractProcessor {

  /* ********************************************************************* */
  /* ProcessingSteps, to be implemented by the user ********************** */
  /* ********************************************************************* */


  /**
   * The unit of processing logic that runs under the guarantee that all elements are complete and
   * well-formed. A {@code ProcessingStep} may reject elements that are not ready for processing but
   * might be at a later processing step or round.
   */
  public interface ProcessingStep {

    /**
     * The set of fully-qualified annotation type names processed by this {@code ProcessingStep}.
     *
     * @return the set of fully-qualified annotation names processed by this {@code ProcessingStep}.
     *
     * <p><strong>Warning</strong>: If the returned names are not the names of annotations,
     * they'll be <em>ignored</em>.
     */
    Set<String> annotations();

    /**
     * The implementation of processing logic for the {@code ProcessingStep}. It is guaranteed
     * that the keys in {@code elementsByAnnotation} will be a subset of the set returned by
     * {@link #annotations()}.
     *
     * @param elementsByAnnotation the elements to be processed mapped to their invoking
     *                             annotation. It is guaranteed that the keys in
     *                             {@code elementsByAnnotation} will be a subset of the set
     *                             returned by {@link #annotations()}. Additionally, the
     *                             well-formedness of the elements are also guaranteed.
     * @return the elements (a subset of the values of {@code elementsByAnnotation}) that
     * this {@code ProcessingStep} is unable to process at the current processing step.
     * These elements are deferred and will be considered again in future steps and rounds
     * of processing, until either properly processed or reported as not processed elements.
     */
    Set<? extends Element> process(ImmutableSetMultimap<String, Element> elementsByAnnotation);
  }

  /**
   * Returns the {@linkplain ProcessingStep}s as specified by the user for this processor.
   * {@link #processingEnv} is guaranteed to be set when this method is invoked.
   *
   * @return {@linkplain ProcessingStep}s provided by the user for this processor.
   */
  protected abstract Iterable<? extends ProcessingStep> processingSteps();

  /**
   * An optional hook for logic to be executed at the beginning of each round.
   *
   * @param roundEnv {@code RoundEnvironment} of the processor.
   */
  protected abstract void preRoundProcess(RoundEnvironment roundEnv);

  /**
   * An optional hook for logic to be executed at the end of each round.
   *
   * @param roundEnv {@code RoundEnvironment} of the processor.
   */
  protected abstract void postRoundProcess(RoundEnvironment roundEnv);

  /**
   * @return true if the annotations should be claimed after the process. Default is {@code false}.
   */
  @SuppressWarnings("SameReturnValue")
  protected boolean shouldClaimAnnotations() {
    return false;
  }

  /* ********************************************************************* */
  /* Processor Mechanism ************************************************* */
  /* ********************************************************************* */

  /* *** Note: In the following namings, TP is the abbreviation of TypeOrPackage *** */
  /**
   * Ill-formed elements are deferred. For more information about well-formedness refer to {@link BaseAnnotationProcessor} documentation.
   */
  private final Set<TPEltName> illInformedTPEltNames = new LinkedHashSet<>();
  private final SetMultimap<ProcessingStep, TPEltName> tPEltNamesDeferredByProcessingSteps = LinkedHashMultimap.create();

  protected Elements eltUtils;
  protected Types typeUtils;
  protected Messager messager;
  protected Filer filer;
  private ImmutableList<? extends ProcessingStep> processingSteps;

  @Override
  public final synchronized void init(ProcessingEnvironment processingEnv) {
    super.init(processingEnv);
    this.eltUtils = processingEnv.getElementUtils();
    this.typeUtils = processingEnv.getTypeUtils();
    this.messager = processingEnv.getMessager();
    this.filer = processingEnv.getFiler();
    this.processingSteps = ImmutableList.copyOf(processingSteps());
  }

  /**
   * Returns the set of supported annotation types as collected from registered
   * {@linkplain ProcessingStep}s.
   *
   * @return the set of supported annotation types as collected from registered
   * {@linkplain ProcessingStep}s.
   */
  @Override
  public final ImmutableSet<String> getSupportedAnnotationTypes() {
    checkState(processingSteps != null);
    return processingSteps.stream()
        .flatMap(processingStep -> processingStep.annotations().stream())
        .collect(toImmutableSet());
  }

  private ImmutableSet<TypeElement> getSupportedAnnotationTypeElements() {
    checkState(processingSteps != null);
    return processingSteps.stream()
        .flatMap(processingStep -> getSupportedAnnotationTypeElements(processingStep).stream())
        .collect(toImmutableSet());
  }

  private ImmutableSet<TypeElement> getSupportedAnnotationTypeElements(ProcessingStep processingStep) {
    return processingStep.annotations().stream()
        .map(eltUtils::getTypeElement)
        .filter(Objects::nonNull)
        .collect(toImmutableSet());
  }

  /**
   * Processes a set of annotation types on type elements
   * originating from the prior round and returns whether or not
   * these annotation types are claimed by this processor.  If {@code
   * true} is returned, the annotation types are claimed and subsequent
   * processors will not be asked to process them; if {@code false}
   * is returned, the annotation types are unclaimed and subsequent
   * processors may be asked to process them.  A processor may
   * always return the same boolean value or may vary the result
   * based on its own chosen criteria.
   *
   * <p>The input set will be empty if the processor supports {@code
   * "*"} and the root elements have no annotations.  A {@code
   * Processor} must gracefully handle an empty set of annotations.
   *
   * @param annotations the annotation types requested to be processed
   * @param roundEnv    environment for information about the current and prior round
   * @return whether or not the set of annotation types are claimed by this processor
   */
  @Override
  public final boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
    checkState(eltUtils != null);
    checkState(typeUtils != null);
    checkState(messager != null);
    checkState(filer != null);
    checkState(processingSteps != null);

    preRoundProcess(roundEnv);

    // If this is the last round, report all of the missing elements if there
    // were no errors raised in the round; otherwise reporting the missing
    // elements just adds noise to the output.
    if (roundEnv.processingOver()) {
      postRoundProcess(roundEnv);
      if (!roundEnv.errorRaised()) {
        reportMissingTPElements(
            ImmutableSet.<TPEltName>builder()
                .addAll(illInformedTPEltNames)
                .addAll(tPEltNamesDeferredByProcessingSteps.values())
                .build()
        );
      }
      return shouldClaimAnnotations();
    }

    process(getWellInformedElements(roundEnv));

    postRoundProcess(roundEnv);

    return shouldClaimAnnotations();
  }

  private void reportMissingTPElements(Set<TPEltName> missingTPEltNames) {
    for (TPEltName missingTPEltName : missingTPEltNames) {
      Optional<? extends Element> missingTPElement = missingTPEltName.getElement(eltUtils);
      if (missingTPElement.isPresent()) {
        messager.printMessage(
            Diagnostic.Kind.ERROR,
            processingErrorMessage(
                "this " + missingTPElement.get().getKind().name()
            ),
            missingTPElement.get()
        );
      } else {
        messager.printMessage(Diagnostic.Kind.ERROR, processingErrorMessage(missingTPEltName.getName()));
      }
    }
  }

  private String processingErrorMessage(String target) {
    return String.format(
        "[AnnotationProcessorError: %s ::] %s was unable to process %s because not all of its "
            + "dependencies could be resolved. Check for compilation errors or a circular "
            + "dependency with generated code.",
        getClass().getSimpleName(), getClass().getCanonicalName(), target);
  }

  /**
   * Finds all the well-informed annotated elements contained within all of the ill-informed elements.
   * Note that the elements deferred by processing steps are guaranteed to be well-informed; therefore,
   * they are ignored (not returned) here, and they will be considered directly in the `process` method.
   * <p>
   * It then returns all these elements together with well-informed elements associated to the current round.
   * All encountered ill-informed elements will be deferred.
   */
  private ImmutableSetMultimap<TypeElement, Element> getWellInformedElements(RoundEnvironment roundEnv) {
    ImmutableSet<TPEltName> prevIllInformedTPEltNames = ImmutableSet.copyOf(illInformedTPEltNames);
    illInformedTPEltNames.clear();

    /* Stores all the previously ill-informed elements that are accessible by `eltUtils`, and all their enclosed elements (excluding (inner) class and interface) */
    ImmutableSetMultimap.Builder<TypeElement, Element> readyPrevIllinformedElementsByAnnotationBuilder = ImmutableSetMultimap.builder();

    for (TPEltName deferredTPEltName : prevIllInformedTPEltNames) {
      Optional<? extends Element> deferredTPElement = deferredTPEltName.getElement(eltUtils);
      if (deferredTPElement.isPresent()) {
        addAllInclusiveEnclosedAnnotatedElementsByAnnotations(
            //It will add the element and its enclosed elements (excluding (inner) class and interface) if there is a matching annotation
            deferredTPElement.get(),
            getSupportedAnnotationTypeElements(),
            readyPrevIllinformedElementsByAnnotationBuilder
        );
      } else {
        // no element with deferredTPEltName could be found (yet).
        // [  At some point the element was seen before, since at some point its TPEltName
        //    was extracted and added to `illInformedTPEltNames;` however, now it is not found. ]
        illInformedTPEltNames.add(deferredTPEltName);
      }
    }
    ImmutableSetMultimap<TypeElement, Element> readyPrevIllInformedElementsByAnnotation = readyPrevIllinformedElementsByAnnotationBuilder.build();

    /* Finding all well-informed Elements mapped to their corresponding annotation (of type TypeElement) */
    ImmutableSetMultimap.Builder<TypeElement, Element> wellInformedEltsBuilder = ImmutableSetMultimap.builder();

    // For optimization purposes, the TPEltNames that have already been verified to be well-informed are stored.
    Set<TPEltName> wellInformedTPEltNames = new LinkedHashSet<>();

    // Look at the elements we've found and the new elements from this round and check for well-informedness.
    for (TypeElement annotationType : getSupportedAnnotationTypeElements()) {
      Set<? extends Element> roundElements = roundEnv.getElementsAnnotatedWith(annotationType); //it automatically recurse to enclosed elements
      ImmutableSet<Element> readyPrevIllInformedElements = readyPrevIllInformedElementsByAnnotation.get(annotationType);

      // Note that the elements deferred by processing steps are guaranteed to be well-informed; therefore,
      // they are ignored (not returned) here, and they will be considered directly in the `process` method.
      for (Element element : Sets.union(roundElements, readyPrevIllInformedElements)) {
        TPEltName tpEltName = TPEltName.forElement(element);
        boolean isWellInformedElement =
            wellInformedTPEltNames.contains(tpEltName) || // for optimization
                (!illInformedTPEltNames.contains(tpEltName) &&
                    // for every element that is not module/package to be well-informed its enclosing-type in its entirety should be well-informed
                    SuperficialValidation.validateElement(
                        element.getKind() == ElementKind.PACKAGE ? element : MoreElements.getEnclosingType(element)) //TODO maybe add Module handling
                );
        if (isWellInformedElement) {
          wellInformedEltsBuilder.put(annotationType, element);
          wellInformedTPEltNames.add(tpEltName);
        } else {
          illInformedTPEltNames.add(tpEltName);
        }
      }

    }

    return wellInformedEltsBuilder.build();
  }

  /**
   * Adds {@code element} and its enclosed elements to {@code annotatedElements} if they are
   * annotated with any annotations in {@code annotationTypes}. Does not traverse to member types of
   * {@code element}, so that if {@code Outer} is passed in the example below, looking for
   * {@code @X}, then {@code Outer}, {@code Outer.foo}, and {@code Outer.foo()} will be added to the
   * multimap, but neither {@code Inner} nor its members will.
   *
   * <pre><code>
   *   {@literal @}X class Outer {
   *     {@literal @}X Object foo;
   *     {@literal @}X void foo() {}
   *     {@literal @}X static class Inner {
   *       {@literal @}X Object bar;
   *       {@literal @}X void bar() {}
   *     }
   *   }
   * </code></pre>
   */
  // The inner class and interface are ignored since they are not (directly) related to the elements definition //TODO (needs a bit more thought)
  private static void addAllInclusiveEnclosedAnnotatedElementsByAnnotations(
      Element element,
      ImmutableSet<TypeElement> annotationTypes,
      ImmutableSetMultimap.Builder<TypeElement, Element> annotatedElements) {

    for (Element enclosedElement : element.getEnclosedElements()) {
      if (!MoreElements.isTypeElement(enclosedElement)) // to skip including the type elements
        addAllInclusiveEnclosedAnnotatedElementsByAnnotations(enclosedElement, annotationTypes, annotatedElements);
    }

    // element.getEnclosedElements() does NOT return parameter elements
    //
    // According to {@link Element} documentation, getEnclosedElements()
    // Returns the elements that are, loosely speaking, directly enclosed by this element.
    // A class or interface is considered to enclose the fields, methods, constructors, and member types that it directly declares.
    // A package encloses the top-level classes and interfaces within it, but is not considered enclosing subpackages.
    // Other kinds of elements are not currently considered enclosing any elements; however, that may change as this API or the programming language evolves.
    //
    // Note that elements of certain kinds can be isolated using methods in ElementFilter.
    if (element.getKind() == ElementKind.METHOD || element.getKind() == ElementKind.CONSTRUCTOR) {
      for (Element parameterElement : MoreElements.asExecutable(element).getParameters()) {
        addAllInclusiveEnclosedAnnotatedElementsByAnnotations(parameterElement, annotationTypes, annotatedElements);
      }
    }

    for (TypeElement annotationType : annotationTypes) {
      if (MoreElements.isAnnotationPresent(element, annotationType)) {
        annotatedElements.put(annotationType, element);
      }
    }

  }

  /**
   * Processes the well-informed elements, including those previously deferred by each step.
   */
  private void process(ImmutableSetMultimap<TypeElement, Element> wellInformedElements) {
    for (ProcessingStep processingStep : this.processingSteps) {
      ImmutableSet<TypeElement> annotationTypes = getSupportedAnnotationTypeElements(processingStep);
      ImmutableSetMultimap<TypeElement, Element> processingStepElements =
          new ImmutableSetMultimap.Builder<TypeElement, Element>()
              // Add previously rejected (deferred) elements by processingSteps. Note that all the members are
              // well-informed, since they were passed to at least one processing step.
              .putAll(getAllInclusiveEnclosedAnnotatedElementsByAnnotations(tPEltNamesDeferredByProcessingSteps.get(processingStep), annotationTypes))
              .putAll(filterKeys(wellInformedElements, Predicates.in(annotationTypes)))
              .build();
      if (processingStepElements.isEmpty()) {
        tPEltNamesDeferredByProcessingSteps.removeAll(processingStep);
      } else {
        Set<? extends Element> rejectedElements = processingStep.process(toClassNameKeyedMultimap(processingStepElements));
        //noinspection StaticPseudoFunctionalStyleMethod
        tPEltNamesDeferredByProcessingSteps.replaceValues(processingStep, transform(rejectedElements, TPEltName::forElement));
      }
    }
  }


  private static ImmutableSetMultimap<String, Element> toClassNameKeyedMultimap(SetMultimap<TypeElement, Element> elements) {
    ImmutableSetMultimap.Builder<String, Element> builder = ImmutableSetMultimap.builder();
    elements.asMap().forEach(
        (annotation, element) -> builder.putAll(annotation.getQualifiedName().toString(), element)
    );
    return builder.build();
  }

  private ImmutableSetMultimap<TypeElement, Element> getAllInclusiveEnclosedAnnotatedElementsByAnnotations(Set<TPEltName> annotatedTPEltNames,
      ImmutableSet<TypeElement> annotationTypes) {
    ImmutableSetMultimap.Builder<TypeElement, Element> annotatedElements = ImmutableSetMultimap.builder();
    for (TPEltName tPEltName : annotatedTPEltNames) {
      Optional<? extends Element> tPElement = tPEltName.getElement(eltUtils);
      tPElement.ifPresent(element -> addAllInclusiveEnclosedAnnotatedElementsByAnnotations(element, annotationTypes, annotatedElements));
    }
    return annotatedElements.build();
  }

  /**
   * A package or type name.
   *
   * <p>It's unfortunate that we have to track types and packages separately, but since there are
   * two different methods to look them up in {@link Elements}, we end up with a lot of parallel
   * logic. :(
   *
   * <p>Packages declared (and annotated) in {@code package-info.java} are tracked as deferred
   * packages, type elements are tracked directly, and all other elements are tracked via their
   * nearest enclosing type.
   */
  @Data
  // Needed to save the names of TPElements instead of the elements, since
  //  1. There is no guarantee that any particular element will always be represented by the same object. (Reference: {@link Element})
  //  2. Since an implementation may choose to have a single object implement multiple Element sub-interfaces. (Reference: {@link Element})
  //  3. and possibly others (such as reconstruction of AST after each round, and direct manipulations of AST by tools like lombok)
  // make the saved element unreliable.
  private static final class TPEltName {
    private enum Kind {
      PACKAGE_NAME,
      TYPE_NAME,
    }


    private final Kind kind;
    /**
     * The fully-qualified name of the element.
     */
    private final String name;

    private TPEltName(Kind kind, Name name) {
      this.kind = kind;
      this.name = name.toString();
    }

    /**
     * An {@link TPEltName} for an element. If {@code element} is a package, it uses the
     * fully qualified name of the package. If it's a type, it uses its fully qualified name.
     * Otherwise, uses the fully-qualified name of the nearest enclosing type.
     *
     * @param element the element whose nearest enclosing type or package name is inquired
     * @return the {@linkplain TPEltName} of the nearest enclosing type or package
     */
    static TPEltName forElement(Element element) {
      return element.getKind() == ElementKind.PACKAGE
          //Here since getKing() is used not "instance of", simple casting will also work. Refer to {@link Element} documentation.
          ? new TPEltName(Kind.PACKAGE_NAME, MoreElements.asPackage(element).getQualifiedName())
          : new TPEltName(Kind.TYPE_NAME, getEnclosingType(element).getQualifiedName());
    }

    /**
     * Returns the {@link Element} whose fully-qualified name is {@link #getName()}. {@link Optional#empty() Empty Optional}
     * if the relevant method on {@link Elements} returns {@code null}.
     *
     * @param eltUtils the element utility of type {@link Elements} of the environment
     * @return the {@link Element} whose fully-qualified name is {@link #getName()}. {@link Optional#empty() Empty Optional}
     * if the relevant method on {@link Elements} returns {@code null}.
     */
    Optional<? extends Element> getElement(Elements eltUtils) {
      return Optional.ofNullable(
          this.kind == Kind.PACKAGE_NAME
              ? eltUtils.getPackageElement(name)
              : eltUtils.getTypeElement(name));
    }

  }

}
